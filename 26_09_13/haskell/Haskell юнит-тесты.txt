
"ghci> " getNextVertex [(1,False),(2,False),(3,False),(4,False),(5,False)] [(1,0),(2,1000),(3,1000),(4,1000),(5,1000)]
1

"ghci> " getOutcomingVertices [(1,[2,3,4,5]),(2,[]),(3,[5]),(4,[2,3]),(5,[1,3,4])] 1
[2,3,4,5]

>getEdgeWeight [("3-5",10), ("5-1",10), ("5-3",10), ("1-5",10), ("1-4",50), ("1-3",30), ("1-2",10), => ("5-4",30), ("4-2",40), ("4-3",20)] 5 1
10.0

>getVertexDistance [(1,0),(2,1000),(3,1000),(4,1000),(5,1000)] 3
=>1000.0

>edgeHasWeight [("3-5",10), ("5-1",10), ("5-3",10), ("1-5",10), ("1-4",50), ("1-3",30), ("1-2",10), ("5-4",30), ("4-2",40), ("4-3",20)] 20 1
=>False

> getNextDistance [(1,0),(2,1000),(3,1000),(4,1000),(5,1000)] [("3-5",10), ("5-1",10), ("5-3",10), ("1-5",10), ("1-4",50), ("1-3",30), ("1-2",10), ("5-4",30), ("4-2",40), ("4-3",20)] 1 2
=>10.0

>getNextDistances [(1,0),(2,1000),(3,1000),(4,1000),(5,1000)] [("3-5",10), ("5-1",10), ("5-3",10), ("1-5",10), ("1-4",50), ("1-3",30), ("1-2",10), ("5-4",30), ("4-2",40), ("4-3",20)] 1 [(1,[2,3,4,5]),(2,[]),(3,[5]),(4,[2,3]),(5,[1,3,4])]
=>[(2,10.0),(3,30.0),(4,50.0),(5,10.0)]

>isChangedDistance 2 10.0 [(1,0),(2,1000),(3,1000),(4,1000),(5,1000)]
=>True

> let xs = [(2,10.0),(3,30.0),(4,50.0),(5,10.0)]
>let ys = [(1,0.0),(2,1000.0),(3,1000.0),(4,1000.0),(5,1000.0)]
>getVerticesWithChangedDistance xs ys
=>[2,3,4,5]

>   getUpdatedParents [(1,1),(2,1),(3,1),(4,1),(5,1)] [2,3,4] 5
=> [(1,1),(2,5),(3,5),(4,5),(5,1)]

>getNextDistances [(1,0),(2,1000),(3,1000),(4,1000),(5,1000)] [("3-5",10), ("5-1",10), ("5-3",10), ("1-5",10), ("1-4",50), ("1-3",30), ("1-2",10), ("5-4",30), ("4-2",40), ("4-3",20)] 1 [(1,[2,3,4,5]),(2,[]),(3,[5]),(4,[2,3]),(5,[1,3,4])]
=>[(1,0.0),(2,10.0),(3,30.0),(4,50.0),(5,10.0)]


>   data ShortestRoutes = ShortestRoutes [(Integer, Integer)] [(Integer, Double)] deriving (Show)
>   let shr = ShortestRoutes [(1,1),(2,1)] [(1,23.0), (2,34.0)]
>   shr
=> ShortestRoutes [(1,1),(2,1)] [(1,23.0),(2,34.0)]

>getUpdatedDistancesParents  [(1,0),(2,1000),(3,1000),(4,1000),(5,1000)] [("3-5",10), ("5-1",10), ("5-3",10), ("1-5",10), ("1-4",50), ("1-3",30), ("1-2",10), ("5-4",30), ("4-2",40), ("4-3",20)] [(1,[2,3,4,5]),(2,[]),(3,[5]),(4,[2,3]),(5,[1,3,4])] [(1,1),(2,1),(3,1),(4,1),(5,1)] 1
=>DistancesParents [(1,0.0),(2,10.0),(3,30.0),(4,50.0),(5,10.0)] [(1,1),(2,1),(3,1),(4,1),(5,1)]

>getUpdatedVisited [(1,False), (2,False), (3,False)] 2
=>[(1,False),(2,True),(3,False)]

>let xs = DistancesParents [(1,0.0),(2,10.0),(3,30.0),(4,50.0),(5,10.0)] [(1,1),(2,1),(3,1),(4,1),(5,1)]
> tellDistances xs
=>[(1,0.0),(2,10.0),(3,30.0),(4,50.0),(5,10.0)]

>tellParents xs
=>[(1,1),(2,1),(3,1),(4,1),(5,1)]

> getUpdatedDistancesParentsVisitedNext  [(1,0),(2,1000),(3,1000),(4,1000),(5,1000)] [("3-5",10), ("5-1",10), ("5-3",10), ("1-5",10), ("1-4",50), ("1-3",30), ("1-2",10), ("5-4",30), ("4-2",40), ("4-3",20)] [(1,[2,3,4,5]),(2,[]),(3,[5]),(4,[2,3]),(5,[1,3,4])] [(1,False),(2,False),(3,False),(4,False),(5,False)] [(1,1),(2,1),(3,1),(4,1),(5,1)]

=>DistancesParentsVisitedNext [(1,0.0),(2,10.0),(3,30.0),(4,50.0),(5,10.0)] [(1,1),(2,1),(3,1),(4,1),(5,1)] [(1,True),(2,False),(3,False),(4,False),(5,False)] 1


